Description:
Este teste foi retirado [Artho04] e consiste num buffer partilhado por diversos processos que removem e adicionam elementos ao mesmo. 
De seguida é ilustrado um fragmento do código deste teste.

public void run(){
	int value, fdata;
	while(true){
		value = next();
		fdata = f(value); //long computation
		add(fdata);
	}
}
@Atomic
private int next(){
	return buffer.next();
}
@Atomic
private void add(int fdata){
	buffer.add(fdata);
}

Documented Anomalies:
1. Segundo os autores, este teste não contém qualquer tipo de anomalias. Sendo que ambos os métodos atómicos acedem ao buffer, parece haver um datarace.
Contudo, os autores afirmam que, assumindo que nenhum elemento é inserido mais do que uma vez, a semântica do programa mantém os dados localmente ao 
processo em questão. A implementação desta assunção não parece ser trivial, não sendo também claro se essa mesma implementação removeria a anomalia. 
Teria de ser feito um estudo mais profundo da semântica do programa, complementando-o com um cenário real que demonstrasse o funcionamento do programa.


Results:
One false positive.
Foi gerado um conflito por parte de um dos sensores devido a uma dependência gerada entre os métodos "next" e "add", já que o valor usado para introduzir 
um elemento parece depender do valor retornado pelo método "next". Apesar da ausência de dataraces ter sido justificada com uma assunção que não foi 
implementada e que não parece clara, consideraremos este conflito como um falso positivo. 


Source:
[AHB04] - Cyrille Artho, Klaus Havelund, e Armin Biere. Using block-local atomicity to detect stale-value concurrency errors. Automated Technology for 
Verification and Analysis, pág. 150–164, 2004