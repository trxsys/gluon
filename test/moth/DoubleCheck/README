Description:
Este teste foi apresentado em [AHB04] como mais um programa isento de dataraces que pode gerar falsos positivos. O código deste exemplo é 
disponibilizado neste documento. De forma a diminuir o tamanho das transacções, diminuindo assim a probabilidade de conflito entre as mesmas, 
o incremento de uma variável é feito em duas operações atómicas. Primeiro, é feita uma cópia do valor da variável, em seguida essa cópia é 
incrementada e, finalmente, o valor da variável é actualizado com o valor da cópia. No entanto, antes de actualizar o valor da variável, 
o processo testa atomicamente se o valor lido inicialmente ainda se mantém, descartando a actualização caso o valor tenha sido alterado.

public void run() {
	int value, fdata;
	boolean done = false;
	while (!done) {			
		value = getSharedField();
		fdata = f(value); // long computation
		done = updateSharedField(fdata);
	}
}
@Atomic
private int getSharedField(){
	return shared.field;	
}
@Atomic
private boolean updateSharedField(int value, int fdata){
	if (value == shared.field) { //Double check...
		shared.field = fdata;
		return true;
	}
	return false;
}

Documented Anomalies:
1. Apesar de parecer existir um stale-value error gerado pela leitura e escrita da variável global, como a actualização verifica se o valor foi 
alterado, este programa não tem qualquer tipo de datarace.


Results:
One false positive.
Foi detectada uma dependência entre os métodos atómicos "getSharedField" e "updateSharedField" tendo sido, por isso, reportado um conflito (falso positivo).
A definição de datarace do "Dependency Sensor", que utiliza o conceito de dependências entre métodos atómicos, teria de ser melhorada de forma a 
excluir este cenário.


Source:
[AHB04] - Cyrille Artho, Klaus Havelund, e Armin Biere. Using block-local atomicity to detect stale-value concurrency errors. Automated Technology for 
Verification and Analysis, pág. 150–164, 2004