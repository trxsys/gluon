Description:
Este benchmark, tal como nome indica, simula o funcionamento de um elevador onde cada andar é representado por um processo concorrente. Cada andar 
tem, em cada momento, um determinado número de pessoas que desejam utilizar o elevador para subir ou descer no edifício. Finalmente, cada processo 
guarda ainda informação sobre o estado do botão desse andar (se está ou não pressionado). Neste documento é apresentado um fragmento do código deste
teste, onde é decidido para que andar o elevador se deve dirigir. Como se pode verificar, sempre que o elevador é chamado por mais do que um andar, 
é dada prioridade ao andar mais baixo.

// ...

for (int floor = firstFloor; !foundFloor && floor <= lastFloor; floor++) {
	if (controls.claimUp(getName(), floor)) { // 2 Atomics
		foundFloor = true;
		targetFloor = floor;
	}
	else if (controls.claimDown(getName(), floor)) { // 2 Atomics
		foundFloor = true;
		targetFloor = floor;
	}
}

// ...

Documented Anomalies:
Tal como foi ilustrado, o elevador percorre todos os andares até achar o primeiro cujo botão que permite chamar o elevador foi pressionado. Cada andar 
só é analisado se, em todos os anteriores, o elevador não tiver sido chamado ("foundFloor" = false). No entanto, entre duas chamadas dos métodos atómicos 
que avaliam se o elevador foi chamado em dois andares distintos, alguém podia ter chamado o elevador no primeiro fazendo com que o elevador não fosse 
para o andar mais baixo (como seria de esperar pela semântica do programa). Como ambos os métodos "claimUp" e "claimDown" são implementados através do 
teste de duas condições em dois métodos atómicos distintos cada um, então este conflito pode acontecer entre qualquer par de métodos dos quatro
referidos (um de cada iteração do ciclo). Assim, este teste contém 4.4 = 16 dataraces.


Results:
Seis falsos positivos.
Os dezasseis dataraces foram correctamente detectados pelo plugin Dependency Sensor. Para além destes, foram ainda reportados 2 conflitos pelo plugin 
ViewConsistency Sensor e 4 pelo Dependency Sensor, num total de 6 falsos positivos.

Os primeiros dois falsos positivos foram gerados devido ao facto da ferramenta MoTH não conseguir distinguir duas instâncias do mesmo objecto. 
A implementação de uma análise points-to poderia ajudar a excluir este tipo de falsos alarmes. Por outro lado, sempre que o elevador se encontra num 
andar, testa atomicamente se o botão desse andar foi pressionado e, caso tenha sido, é utilizado outro método atómico que corresponde à entrada das 
pessoas no elevador. Assim, foram criadas dependências entre os quatro métodos atómicos referidos e o método atómico que introduz as pessoas no 
elevador gerando consequentemente quatro conflitos. Intuitivamente, se entre o teste atómico que verifica se alguém carregou no botão e a abertura 
das portas para as pessoas entrarem o botão fosse "cancelado", então estaríamos a abrir as portas sem que ninguém estivesse no andar corrente. No 
entanto, apesar de outros processos poderem escrever nas variáveis que representam o botão desse andar, essa escrita corresponde à acção de carregar 
no botão, não influenciando em nada a abertura das portas. Para excluir este conflito seria necessário apurar o valor usado na afectação da variável 
que representa o botão, o que seria extremamente difícil (ou mesmo impossível) utilizando análise estática.

Source:
[vG03] - Christoph von Praun e Thomas R. Gross. Static detection of atomicity violations in object-oriented programs. In Journal of Object Technology, 
pág. 2004, 2003.